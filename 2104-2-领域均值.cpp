//一道二维的差分题
/*
题目大意：
    有一个n*n像素的图片，需要判断当中有多少个像素处于较暗区域
    较暗区域的判断:
        对于某个节点(i,j)，如果其距离r的邻域内|x-i|<=r & |y-j|<=r（x,y必须在图内）
        所有节点的像素平均值小于等于给定阈值t
        则该节点处于较暗区域，反之则不处于
    （题目意思还是很好理解的）

先想暴力算法：
    暴力其实很简单，我们就遍历每个节点O(n*n)，
    对于每个节点算邻域内像素平均值，并判断是否在较暗区域O(r*r)
    最终输出结果
    这样正确性没有问题，但是复杂度O(n*n*r*r)，会超时，只能拿70分

由于第二题考差分的实在太多了，稍微有引导作用，再加上自己的一些思考
也就顺利地想到了二维差分数组的解法

第一次优化（还没到差分）：
    想着O(n*n)的复杂度是不可避免的，能不能优化O(r*r)
    一开始想的是提前终止循环：
        实际上领域均值小等于t，也就是领域之和超过num*t
        那如果已经超过就结束循环即可
    
    这样确实快一些，但是复杂度多项式没有变

第二次优化(到差分):
    之前很多差分的题目都是换一个角度来算的：
        比如本题，我们不是以一个节点为中心去求取其邻域的像素平均值（求平均值和求和没什么区别）吗？
        如果我们输入每一个像素的时候，就把和它互为邻域（领域是相互的）的节点像素值加上该像素
        对于一个点，将他邻域（实际上是一个矩形）内的值统一加x
        这不就是差分的思想吗？只不过是二维的差分

二维的差分数组:
    具体的思路就不赘述了
    先根据输入的n*n的像素值计算差分数组
    再根据差分数组计算邻域像素和数组（原始数组）
    最后统计一遍
    复杂度O(n*n)

最终AC。

*/
#include<iostream>
using namespace std;
const int maxn = 700;
int sum[maxn][maxn];  //每个点领域之和
int b[maxn][maxn];  //二维差分数组
int num[maxn][maxn];  //领域有几个数
int n;
void insert(int x1, int y1, int x2, int y2, int d)
{
    //区间内所有值+=d
    b[x1][y1] += d;
    b[x2+1][y1] -= d;
    b[x1][y2+1] -= d;
    b[x2+1][y2+1] += d;
}
int main(){
    int L, r, t;
    cin >> n >> L >> r >> t;
    int a;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            cin >> a;
            int x1 = max(0, i-r), y1 = max(0, j-r), x2 = min(i+r, n-1), y2 = min(j+r, n-1);
            insert(x1, y1, x2, y2, a);
            num[i][j] = (x2-x1+1) * (y2-y1+1);
        }
    }
    //求原矩阵
    int ans = 0;
    sum[0][0] = b[0][0];
    for (int i = 1; i < n; i++)
    {
        sum[0][i] = sum[0][i-1] + b[0][i];
        sum[i][0] = sum[i-1][0] + b[i][0];
    }
    for (int i = 1; i < n; i++)
    {
        for (int j = 1; j < n; j++)
        {
            sum[i][j] = b[i][j] - sum[i-1][j-1] + sum[i-1][j] + sum[i][j-1];
        }
    }
    cout << ans;
    return 0;
}