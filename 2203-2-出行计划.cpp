//CSP202203-2  出行计划

/*
不得不感慨：算法真牛逼！差分数组真牛逼！
可能对于ACMer来说，差分数组low得不能再low了，但是对于我这个算法小白来说，还是十分感慨其美妙。
自己也想了一个不那么无脑的暴力解法，不过并没有什么收益。

这道题理解题目意思不难：
    给定n个计划，每个计划表示在t时刻到某个地方，而该地方要求c时刻内的核酸报告
    做核酸到出结果的时间是k
    给m个时间需要查询：
        对于每个时间q，回答有几个计划能够实现
    
对于单个时间查询单个计划能成功的判别为：
    q+k <= t <= q+k+c-1

最暴力的方法就是直接无脑循环：
    对于m个时间依次查询：
        对于n个计划依次判断
    时间复杂度O(m*n)  ps: m/n最大到10e5，复杂度直接爆了

由于不知道差分数组这种复杂度O(n) -> O(1)的算法，我起初认为双重循环不可避免，
只能说利用题目给的条件(n个计划按时间排序，m个查询时间也是顺序)尽可能减少判断，
简单说一下思路吧，感觉也还算巧妙，不过不够巧妙：
    可以转换一下，核酸结果时间是q+k，需要判断它在不在一个地方可以接受的范围内：
        t-c+1 <= q+k <= t
        (你要在t时刻来，那么你的核酸报告应该是t-c+1到t内有效的)
    由于n个计划实际上是按t从小到大排序的，
    对于某个确定的时间q+k，我们可以反着查询，从n查到1：
        当某个1<=x<=n，q+k > t[x]，也就是说核酸结果的时间在访问之后才出，那么显然不成立
        同时，前面的x次都不用判断力，因为肯定不成立，这是对于单次查询的内部优化
    
    实际上还可以进行优化（根据查询时间也是从小到大排序）
    比如说第一次查询q1+k，第二次查询q2+k，显然有后者大于前者
    如果第一次查询时，前x个计划的t<q1+k，显然前x个计划的t<q2+k
    这意味着后续的查询都可以略过前x个计划

    这双层的优化之后，后续的查询成本是越来越低的，感觉可以得到很大的优化
    时间复杂度还是O(m*n)
    最后也证明，只能拿70分，优化力度不够
    失败原因一方面是自己不知道差分数组这种做法；另一个是题目按顺序的条件误导，实际上这个条件没什么用。

标准解法——差分数组:
    通常差分数组要和前缀和数组一起讲，这里直接讲差分数组
    举一个差分数组的例子:
    原始数组{8, 2, 6, 3, 1} -> 差分数组{8, -6, 4, -3, -2}
    差分数组就是第一个元素不动，后续所有元素的值都减去原始数组当中前一个元素的值
    差分数组还原回原始数组只需要arr[i]+=arr[i-1]

    差分数组通常应用于对某个区间所有元素进行统一的加减：
        比如对于arr[i:j]统一+=1
    传统方法就是循环，复杂度O(n)

    但是实际上，利用差分数组，我们只需要差分[i]+=1，差分[j+1]-=1即可
    复杂度是O(1)

    为什么呢，因为差分[i] = arr[i] - arr[i-1]，如果arr[i]+=1，自然差分[i]+=1
    而对于i<x<=j，差分[x] = arr[x] - arr[x-1]，前后两个数都+1，在差分数组上就是不变
    对于j+1，差分[j+1] = arr[j+1] - arr[j]，由于前者不变，后者+1，自然差分值-1

    差分数组的应用就解释完了，接下来回到本题

    我们可以把时间理解成一个数轴
    对于每个计划的t，c都可以确定一个区间[t-k-c+1, t-k]，只要是在区间内的时间做核酸，计划就能完成
    因此数轴上每个时间点所能完成的计划就+1
    n个计划就有n个这样的区间，对每个区间当中的点+1，最后直接查该点对应的值就是q的输出

    对于区间统一加减就可以用到前面说的差分数组了
    每个区间复杂度O(1)
    n个计划O(n)
    查询复杂度O(m)
    最终复杂度O(max(m,n))
    大大降低了复杂度

以上。
*/
#include<iostream>
#include<vector>
#include<cstring>
using namespace std;
const int maxt = 2e5 + 10;  //最大时间范围
int ans[maxt];
int main(){
    memset(ans, 0, sizeof(ans));
    //全是0的差分数组不需要构建
    int n, m, k, t, c, q;
    cin >> n >> m >> k;
    for (int i = 0; i < n; i++)
    {
        cin >> t >> c;
        int begin = t - k - c + 1;
        int end = t - k;
        if (end <= 0)
        {
            continue;
        }
        begin = max(1, begin);
        ans[begin]++;
        ans[end+1]--;
    }
    //差分数组还原
    for (int i = 1; i < maxt; i++)
    {
        ans[i] = ans[i] + ans[i-1];
    }
    //处理查询
    for (int i = 0; i < m; i++)
    {
        cin >> q;
        cout << ans[q] << endl;
    }
    return 0;
}